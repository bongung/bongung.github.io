---
title: FTZ level9
published: true
---

* * * 

# ftz level9(gdb)

![ftz1](./assets/ftz1.png){: width="650" height="350"}

먼저 ls를 입력해서 안에 hint 파일이 있나 확인해보자.

다행히도 hint파일이 있다. cat hint를 입력해서 hint의 내용을 보자.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

main(){

  char buf2[10];
  char buf[10];

  printf("It can be overflow : ");
  fgets(buf,40,stdin);

  if ( strncmp(buf2, "go", 2) == 0 )
   {
        printf("Good Skill!\n");
        setreuid( 3010, 3010 );
        system("/bin/bash");
   }

}
```

* * *

음...복잡해보이는 코드들이 나오는데  대충 해석해보면 

char 형으로 buf2와 buf를 배열의 크기를 10으로해서 선언한뒤 

It can be overflow를 출력해주고 

fgets로 입력을 받는데 입력한 값을 buf안에 넣어주고 최대 40개의 문자만 입력받게한다.

그 다음 조건문을 써서 buf2배열에 크기가 go와 같을때

Good Skill!을 출력하고 uid를 재설정해서 bash에 들어갈 수 있게 하는 것 같다.

* * *

이제 이 hint에 나와있는 코드가 있는 /bin으로 이동해보자 

이동한뒤 ls를 쳐보면 이상하게도  bof라는 파일이 없다. 

그래서 나는 만들어줬다. /bin에서 vi를 이용해서 만들면 안될것이다. 검색해보니 아마 /bin에서 파일을 만들 권한이 없는 것 같다.

그래서 나는 /tmp 여기에 vi로 이름을 bof.c로 해서 위에 코드들을 그대로 써서 만든뒤 

gcc -o bof bof.c를 입력해서 실행파일까지 만들었다.

![](./assets/ftz2.png){: width="650" height="350"}

* * *

bof를 ./bof를 입력해서 실행시켜보면 

>>It can be overflow: 

이렇게 뜨는데 level9는 bof문제이니 그냥 a를 막써보면 

안된다. 몇개를 써야 오버플로우가 일어나는지 보자.

우선 fgets로 40개만 받아와서 bof에 입력해주니까 bof는 배열크기가  10이니까 a를 10개 써준다고 가정하고 

bof가 꽉 채워졌으니까 a를 2개 더쓰면 오버플로우가 일어나지 않을까? 해서 a를 12개 써주면 

안된다.

왜 안되는지 알기위해서 gdb로 코드를 어셈블리어로 볼 필요가 있다.

![](./assets/ftz3/png){: width="650" height="350"}





